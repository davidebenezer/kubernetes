Q&A Chapter 2
===============

1. Which Flag can you use with kubeadm to supply a custom configuration file?  --config
2. what does 8 in k8s specify? 8 letters between k and s in kubernetes
3. which kubernetes component manages containers on an individual node? kubelet
4. what is the primary feature of kubernetes? Container Orchestration
5. what is a namespace? A mechanism for isolating groups of resources within a single cluster.
6. Which flag allows you to specify which Namespace you want to interact with when using kubectl? -n or --namespace
7. What is Kubernetes control pane? A collection of components that manage the cluster globally
8. What does kubeadm do? Simplifies the process of building kubernetes clusters


Notes:
======

Kompas  - Helps in migrating docker compose to kubernetes objects
Helm - Use chart to maintain kubernetes templates to easily create complex architecture
Kustomize - Used for maintaining kubernetes templates similar to Helm

High Availability -- We need to have more than one Controle Plane(e.g Node1, Node2) In that case we need to 
	* communicate to kube-api-server through load balancer
	* Kubelet uses the load balancer to communicate with kube api server
	
Design patters for etcd in multi control plance set up
Design Pattern 1:
	stacked etcd - (kube-api as well run on each control pane node)etcd run in same node as control pane. 
					each control plane will have its own etcd instance
Design Pattern 2:
	external etcd - etcd will run outside of control pane nodes. Multiple etcd will be running.
	
What is draining?
	when performing maintenancy, you may sometimes need to remove a kubernetes node from sevice
	To do this, you can drain the node. Containers running on the node will be gracefully terminated (and potentially rescheduled on another node).
	
	Ignoring Daemon Sets:
		When draining a node, you may need to ignore DaemonSets(pods that are tied to each node). If you have DaemontSet pods running on the
			node, you will likely need to use the --ignore-daemonsets flag.
			
	$ kubectl drain <node name> --ignore daemonsets
	
	(drain might error out if we dont ignore daemonsets)
	
Uncordoning a Node1
	If the node remains part of the cluster, you can allow pods to run on the node again when maintenance is complete using 
		kubectl uncordon command.
	
	$ kubectl uncordon <node name>
	
etcd
****

Why backup etcd?
	etcd is the backend data storage solution for your kubernetes cluster. As such, all your kubernetes objects, application, and configurations
		are stored in etcd.
		Therefore, you will likely want to be able to back up your cluster's data by backing up etcd.
		You can backup etcd using etcd command line tool etcdctl.
		
		
		Backup etcd
		***********
		$ ETCDCTL_API=3 etcdctl --endpoints $ENDPOINT snapshot save <file name>
		
		Restore etcd
		************
		$ ETCDCTL_API=3 etcdctl snapshot restore <file name>
		
		Restore creates a temporary logical cluster in order to re populate the data from saved backup file.
		
Q&A Chapter 2
=============

1. which tool provides a command-line interface for kubernetes? kubectl
2. which software does kubernetes use to store data about the stare of the cluster? Etcd
3. Which tool(s) allow you to create Kubernete clusters? MiniKube, Kubeadm (Helm allows you to template k8s object, it does not help build clusters)
4. Which command is used to safely evict your pods from a node before maintenance on the node? kubectl drain
5. What command can you use to allow Pods to be scheduled on a previously-drained node after Node maintenance is complete? kubectl uncordon
6. Which tool can help you perform a Kubernetes upgrade? kubeadm
7. which of the following options are for a highly-available Etcd architecture? External Etcd, Stacked Etcd
8. Which command allows you to upgrade control plane components? Kubectl upgrade apply
9. Which command-line tool allows you to interact with Etcd and perform backups? etcdctl
10. How can you make Kubernetes highly available? Have multiple control plane nodes

Notes:
======

what id kubectl? 
	kubectl is a command line tool that allows you to interact with kubernetes. kubectl uses the Kubernetes API to communicate with the cluster
		and carry out your commands.
		" You can use kubectl to deploy applications, inspect and manage cluster resources, and view logs".
		
kubectl get
***********
	Use kubectl get to list objects in the Kuubernetes cluster.
	
	$ kubectl get <object type> <object name> -o <output> --sort-by <JSONPath> --selector <selector>
	
kubectl describe
****************
	You can get detailed information about Kubernetes objects using kubect describe
	
	$ kubectl describe <object type> <object name>

kubectl create
**************
	Use kubectl create to create objects
	
	Supply a YAML file with -f to create an object from a YAML descriptor stored in the file.
	
	If you attempt to create an object that already exists, an error will occur.
	
	$ kubectl create -f <file name>
	
kubectl apply
*************
	kubectl apply is similar to kubectl create. However, if you use kubectl apply on an object that already exists, it will modify the
		existing object, if possible.
		
	$ kubectl apply -f <file name>
	
Kubectl delete
**************
	kubectl delete <object type> <object name>
	
kubectl exec
************
	kubectl exec can be used to run commands inside containers. Keep in mind, in order for a command to succeed, the necessary software
		must exist within the container to run it.
	For pods with  multiple containers, specify the container name with -c. Not needed for pod with only one container
		
	$ kubectl exec <pod name> -c <container  name> -- <command>
	
kubectl get (provides additional info)

kubectl api-resources (gives complete list of resources)

RBAC in K8s
===========

	Role-based access control(RBAC) in K8s allows you to control what users are allowed to do and access within your cluster.
	For ex, you can use RBAC to allow developers to read metadata and logs from Kubernetes pods but not make changes to them.
	
RBAC Objects
============
	Role & Cluster role
	*******************
	
	Roles and ClusterRoles are Kubernetes objects that define a set of permissions. These permissions determine what users can do in the cluster.
	A Role defines permissions within a particular namespace, and a ClusterRole defines cluster-wide permissions not specific to a single 
		namespace
	
	Role Binding and Cluster Role Binding
	*************************************
	
	Role Binding and ClusterRoleBinding are objects that connect Roles and Cluster Roles to users.
	Role Ref connects Role Binding to the actual Role
	
	
What is a Service Account?
	
	In k8s, as service account is an account used by container processes within Pods to authenticate with the K8s API
	If your pods need to communicate with the K8s API, you can use service accounts to control their access
	
		apiversion: v1
		kind: ServiceAccount
		metadata:
			name: my-serviceaccount
			
	You can managge access control for service accounts, just like any other user, using RBAC objects.
	
	Bind service accounts with ClusterRoles or ClusterRoleBindings to provide access to K8s API functionality.
	

Kubernetes Metrics Server
=========================

	In order to view metrics about the resources pods and containers are using, we need an add-on to collect nd provide that data.
		One such add-on is Kubernetes Metrics Server.
		
	Kubectl top
	***********
		with kubectl top, you can view data about resource usage in your pods and nodes. kubectl top also supports flags like
			--sort-by and --selector.
			
		$ kubectl top pod --sort-by <JSONPath> -- selector <selector>

Q&A
***

1. How can you assign permissions to ServiceAccounts? RBAC
2. Which flag allows you to save the command that was used to make a change? --record
3. When using kubectl get, which flag allows you to filter results by label? --selector
4. Which Kubernetes object defines a set of permissions and exists outside of any Namespace? ClusterRole
5. Which tool collects data about resource usage by each container/Pod? Metrics Server
6. Which command can be used to display resource usage data for Pods? kubectl top
7. Which Kubernetes Object can apply a Role to a user or ServiceAccount, but only within a particular Namespace? RoleBinding
8. Which flag allows you to see what would happen when creating an object without actually creating the object? --dry-run=client
9. Which object allows you to create an account used by Pods to access the Kubernetes API? ServiceAccount
10. Which command shows detailed information about a Kubernetes object in a human-readable format? kubectl describe


Managing Application Configuration
**********************************
	When you are running applications in Kubernetes, you may want to pass dynamic values to your applications at runtime to control
		how they behave. This is known as application configuration.
		
	ConfigMaps
	**********
		You can store configuration data in Kubernetes using ConfigMaps. ConfigMaps store data in the form of a key-value map.
			ConfigMap data can be passed to your container applications.
			
		apiVersion: v1
		kind: ConfigMap
		metadata:
			name: my-configmap
		data:
			key1: value1
			key2: value2
			key3:
				subkey:
					morekeys: data
					evenmore: some more data
			key4:
				you can also do multi-line data.
				
	Secrets:
	********
		Secrets are similar to ConfigMaps but are designed to store sensitive data, such as passwords or API keys, more securely. They are 
			created and used similarly to ConfigMaps. Secret values should be base64 encoded
			
		apiVersion: v1
		kind: Secret
		metadata:
			name: my-secret
		type: Opaque
		data:
			username: user
			password: mypass
		
	Environment Variables
	*********************
		You can pass ConfigMap and Secret data to your containers as environment variables. These variables will be visible to container process
			at runtime.
			
			pod specification
			*****************
			spec:
				containers:
				- ...
					env:
					-name : ENVVAR
					 valueFrom:
						configMapKeyRef:
							name: my-configmap
							key: mykey
	
	Configuration Volumes
	*********************
		Configuration data from ConfigMaps and Secrets can also be passed to containers in the form of mounted volumes. This will cause the
			configuration data to appear in files available to the container file system.
		Eah top-level key in the configuration data will appear as a file containing all keys below that top-level key.
		
			...
			volumes:
			- name: secret-vol
			  secret:
			    secretName: my-secret
	
	

Managing Container Resources
============================

	Resource Requests
	*****************
		Resource requests allow you to define amount of resources(such as CPU or memory) you expect a container to use. The Kubernetes
			scheduler will use resource requests to avoid scheduling pods on nodes that do not have enough available resources.
			
			Tip: Containers are allowed to use more(or less) than the requested resources. Resource request only affect the scheduling.
			It does not force the container to remain within the limits
			
		Memory is measured in bytes. CPU is measured in CPU units, which are 1/1000 of one CPU.
		
			apiVersion: v1
			kind: Pod
			metadata:
				name: my-pod
			spec:
				containers:
				- name: busybox
				  image: busybox
				  resources:
				    requests:
					  cpu: "250m"
					  memory: "128Mi"
					  
	Resource Limits
	***************
		Resource limits provide a way for you to limit the amount of resources your containers can use. The container runtime is
			responsible for enforcing these limits, and different container runtimes do this differently.
			
			Tip: Some runtimes will enforce these limits by terminating container processes that attempt to use more than
				the allowed amount of resources.
				
				apiVersion: v1
				kind: Pod
				metadata:
					name:  my-pod
				spec:
					containers:
					- name: busybox
					  image: busybox
					  resources:
					    limits:
						  cpu: "250m"
						  memory: "128Mi"
						  
Monitoring Container Health With Probes
=======================================
	Container Health
	****************
		K8s provides a number of features that allow you to build robust solutions, such as the ability to automatically restart
			unhealthy containers. To make the most of these features, K8s needs to be able to accurately determine the status 
			of your applications. This means actively monitoring container health.
			
		Liveness Probes
		***************
			Liveness probes allow you to automatically determine whether or not a container application is in a healthy state.
			
			By Default , K8s will only consider a container to be "down" if the container process stops.
			
			Liveness probes allow you to customize this detection mechanism and make it more sophisticated.
			
		Startup Probes
		**************
			Startup probes are very similar to liveness probes. However, while liveness probes run constantly on a schedule,
				start up probes run at container startup and stop running once they succeed. 
			
			They are used to determine when the application has successfully started up. Start up probes are especially useful for 
				legacy applications that can have a long startup times.
				
		Readiness Probes
		****************
			Readiness probes are used to determine when a container is ready to accept requests. When you have a service backed by 
				multiple container endpoints, user traffic will not be sent to a particular readiness checks defined by their
				readiness probes.
			
			Use readiness probes to prevent user traffic from being sent to pods that are still in the process of starting up
      

Building Self Healing Pods
==========================
  Restart Policies
  ****************
    K8s can automatically restart containers when they fail. Restart policies allow you to customize this behaior by defining when you 
      want a pod's containers to be automatically restarted.
      
    Restart policies are an important component of self-healing applications, which are automatically repaired when a problem arises.
    
    There are three possible values for a pod's restart policy in K8s: Always, OnFailure and Never
    
    Always:
    *******
      Always is the default restart policy in K8s. With this policy, containers will always be restarted if they stop, even if they 
        completed successfully. Use this policy for applications that should always be running.
        
    OnFailure:
    **********
      The OnFailure restart policy will restart containers only if the container process exits with an error code or the container is
        determined to be unhealthy by a liveness probe. Use this policy for applications that need to run successfully and then stop.
        
    Never:
    ******
      The Never restart policy will cause the pod's containers to never be restarted, even if the container exits or a liveness probe fails.
        Use this for applications that should run once and never be automatically restarted
  
  
Multi Container Pod
===================
what is a Multi-Container Pod?
  A Kubernetes Pod can have one or more containers. A Pod with more than one container is a multi-container Pod.
  
  In a multi-container Pod, the containers share resources such as network and storage. They can interact with one another, working
    together to provide functionality.
   
  Best Practice: Keep containers in separate Pods unless they need to share resources.
   
  Cross-Container Interaction
  ***************************
    Containers sharing the same Pod can interact with one another using shared resources.
    
    Network:
    ********
      Containers share the same networking namespace and can communicate with one another on any port, even if that port is not 
        exposed to the cluster.
        
    Storage:
    ********
      Containers can use volumes to share data in a Pod.
      
    Example Use Case
    ****************
      You have an application that is hard-coded to write log output to a file on disk.
      
      You add a secondary container to the Pod (sometimes called a sidecar) that reads the log file from a shared volume and print it
        to the console so the log output will appear in the container log.
      

Init Containers
===============
  Init Containers are containers that run once during the startup process of a pod. A pod can have any number of init containers, and they
    will each run once (in order) to completion.
  
  Each init container runs in sequence. Only when the first init container runs, the second will start and actual container will be started 
    once all the init containers are started in order.
  
  You can use init containers to perform a variety of startup tasks. They can contain and use software and setup scripts that are not 
    needed by your main containers.
    
  They are often useful in keeping your main containers lighter and more secure by offloading startup tasks to a separate container.
  
  Use cases for initi containers
  ******************************
    Some sample use cases for init containers:
    
    * Cause a pod to wait for another K8s resource to be created before finishing startup.
    * Perform sensitive startup steps securely outside of app containers
    * Populate data into a shared volume at startup
    * Communicate with another service at startup
  
		
Q&A
***

1. When do init containers run? Run to completion before the main container(s) start
2. which of the following probes run only during the container startup process? Startup probes
3. What kubernetes feature can you use to prevent containers from using more than a set amount of resources? Resource limits
4. What does a resource request do(select all that apply)? Prevents Pods from being scheduled on Nodes without sufficient resources.
                                                           Allows you to define the amount of resources you expect a container to use.
5. what can you use to customize how Kubernetes measure the health of a container? Liveness probe
6. Which of the following are ways containers sharing the same Pod can interact? (choose all that apply) 
      Shared Storage Volumes
      Network ports that are not exposed to cluster
7. You have a container that is designed to run a batch job. It needs to run successfully, but should not be run again once it succeeds.
    which restart policy should you use? OnFailure
8. What can you use to customize what happens when a container stops running? Restart Policy
9. Which of the followig situations could init containers be used for? 
    * Make a Pod wait for another resource to be available before finishing startup.
    * Put data into a shared volume so that the main container(s) can access it.
    * Perform startup steps involving sensitive data outside the main container(s).
10. How  many containers can you have per Pod? Atleast one or more
11. What object should you use to store a password? Secret
12. What object should you use to store non-sensitive configuration data? ConfigMap
